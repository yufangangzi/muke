const prototype3 = {
  'js-7': [
    'js 中实现继承的两种模式：原型链继承和借用构造函数继承。这两种模式都存在各自的缺点，所以，我们考虑是否能将这二者结合到一起，从而发挥二者之长。即在继承过程中，既可以保证每个实例都有它自己的属性，又能做到对一些属性和方法的复用。这样就 perfect 了。',
    '<em>一、回顾借用构造函数继承的缺点</em>',
    '先看我们之前在借用构造函数继承中最后用到的代码：',
    '<img src="/assets/images/proto7.png" alt="">',
    '在这段代码中，我们通过借用构造函数继承，保证了 stu1 和 stu2 都有各自的父类属性副本，从而使得各自 emotion 互不影响。但同时带来的问题是，stu1 和 stu2 都拷贝了 Person 类中的所有属性和方法，而在 Person 类中，像 eat ( ), sleep ( ), run ( ) 这类方法应该是公用的，而不需要添加到每个实例上去，增大内存，尤其是这类方法较多的时候。',
    '<em>二、结合使用两种继承模式</em>',
    '所以我们想到，是否能把这些方法挂载到父类的原型对象上去，实现方法复用，然后子类通过原型链继承，就能调用这些方法啦？',
    '<img src="/assets/images/proto8.png" alt="">',
    '首先，我们将 Person 类中需要复用的方法提取到 Person.prototype 中，然后设置 Student 的原型对象为 Person 类的一个实例，这样 stu1 就能访问到 Person 原型对象上的属性和方法了。其次，为保证 stu1 和 stu2 拥有各自的父类属性副本，我们在 Student 构造函数中，还是使用了 Person.call ( this ) 方法。如此，结合原型链继承和借用构造函数继承，就完美地解决了之前这二者各自表现出来的缺点。'
  ]
}
export default prototype3
