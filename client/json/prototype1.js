const prototype1 = {
  'js-5': [
    '面向对象编程都会涉及到继承这个概念，JS中实现继承的方式主要是通过原型链的方法。',
    '<em>一、构造函数、原型与实例之间的关系</em>',
    '每创建一个函数，该函数就会自动带有一个 prototype 属性。该属性是个指针，指向了一个对象，我们称之为 原型对象。什么是指针？指针就好比学生的学号，原型对象则是那个学生。我们通过学号找到唯一的那个学生。假设突然，指针设置 null, 学号重置空了，不要慌，对象还存在，学生也没消失。只是不好找了。',
    '原型对象上默认有一个属性 constructor，该属性也是一个指针，指向其相关联的构造函数。',
    '通过调用构造函数产生的实例，都有一个内部属性，指向了原型对象。所以实例能够访问原型对象上的所有属性和方法',
    '所以三者的关系是，每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。通俗点说就是，实例通过内部指针可以访问到原型对象，原型对象通过constructor指针，又可以找到构造函数。',
    '下面看一个例子：',
    'function Dog (name) {</br>  this.name = name;</br>  this.type = "Dog"; </br>}</br>Dog.prototype.speak = function () {</br>　　alert("wang");</br>}</br>var doggie = new Dog("jiwawa");</br>doggie.speak();  //wang ',
    '以上代码定义了一个构造函数 Dog(),  Dog.prototype 指向的原型对象，其自带的属性construtor又指回了 Dog，即  Dog.prototype.constructor == Dog. 实例doggie由于其内部指针指向了该原型对象，所以可以访问到 speak方法。',
    '<img style="width:100%" src="/assets/images/proto1.png" alt="">',
    'Dog.prototype 只是一个指针，指向的是原型对象，但是这个原型对象并不特别，它也只是一个普通对象。假设说，这时候，我们让 Dog.protptype 不再指向最初的原型对象，而是另一个类 （Animal）的实例，情况会怎样呢？',
    '<img style="width:100%" src="/assets/images/proto2.png" alt="">',
    '<em>二、原型链</em>',
    '前面我们说到，所有的实例有一个内部指针，指向它的原型对象，并且可以访问原型对象上的所有属性和方法。doggie实例指向了Dog的原型对象，可以访问Dog原型对象上的所有属性和方法；如果Dog原型对象变成了某一个类的实例 aaa，这个实例又会指向一个新的原型对象 AAA，那么 doggie 此时就能访问 aaa 的实例属性和 AA A原型对象上的所有属性和方法了。同理，新的原型对象AAA碰巧又是另外一个对象的实例bbb，这个实例bbb又会指向新的原型对象 BBB，那么doggie此时就能访问 bbb 的实例属性和 BBB 原型对象上的所有属性和方法了。',
    '这就是JS通过原型链实现继承的方法了。看下面一个例子：',
    '//定义一个 Animal 构造函数，作为 Dog 的父类</br>function Animal () {</br>    this.superType = "Animal";</br>}</br>Animal.prototype.superSpeak = function () {</br>    alert(this.superType); </br>} </br>function Dog (name) { </br>    this.name = name;</br>    this.type = "Dog";</br>}</br>//改变Dog的prototype指针，指向一个 Animal 实例</br>Dog.prototype = new Animal();</br>//上面那行就相当于这么写</br>//var animal = new Animal();</br>//Dog.prototype = animal;</br> Dog.prototype.speak = function () {</br>　alert(this.type);</br>}</br>var doggie = new Dog("jiwawa");</br>doggie.superSpeak();  //Animal',
    '<img style="width:100%" src="/assets/images/proto3.png" alt="">',
    '这就说明，我们可以通过原型链的方式，实现 Dog 继承 Animal 的所有属性和方法',
    '总结来说：就是当重写了Dog.prototype指向的原型对象后，实例的内部指针也发生了改变，指向了新的原型对象，然后就能实现类与类之间的继承了',
    '但是如果在重写原型对象之前，产生的实例，其内部指针指向的还是最初的原型对象。',
    '<em>三、原型链的缺点</em>',
    '<b>1.1 单纯的原型链继承最大的一个缺点，在于对原型中引用类型值的误修改。</b>',
    '先看一个例子：',
    '<img src="/assets/images/proto4.png" alt="">',
    '以上例子，我们通过重写 Student.prototype 的值为 Person 类的一个实例，实现了 Student 类对 Person 类的继承。所以 ，stu1 能访问到父类 Person 上定义的 head 属性，打印值为“脑袋瓜子”。我们知道，所有的 Student 实例都共享着原型对象上的属性。那么，如果我在 stu1 上改变了 head 属性值，是不是会影响原型对象上的 head 值呢？看我上面的代码就知道，肯定是不会。stu1 的 head 值确实是改变了，但是我重新实例化的对象 stu2 的 head 值仍旧不变。',
    '这是因为，当实例中存在和原型对象上同名的属性时，会自动屏蔽原型对象上的同名属性。stu1.head = "聪明的脑袋瓜子" 实际上只是给 stu1 添加了一个本地属性 head 并设置了相关值。所以当我们打印 stu1.head 时，访问的是该实例的本地属性，而不是其原型对象上的 head 属性（它因和本地属性名同名已经被屏蔽了）。',
    '刚才我们讨论的这个 head 属性是一个基本类型的值，可如果它是一个引用类型呢？这其中又会有一堆小九九。',
    '其实原型对象上任何基本类型的值，都不会被实例所重写/覆盖。在实例上设置与原型对象上同名属性的值，只会在实例上创建一个同名的本地属性。',
    '但是，原型对象上引用类型的值可以通过实例进行修改，致使所有实例共享着的该引用类型的值也会随之改变。',
    '再看下面这个例子：',
    '<img src="/assets/images/proto5.png" alt="">',
    '我们在刚才的 Person 类中又添加了一个 emotion 情绪属性，人都有喜怒哀乐嘛。尤其需要注意的是，这是一个引用类型的值。这时，stu1 认为他还很“愁”，所以就通过 stu1.emotion.push ( ) 方法在原来的基础上增加了一项情绪，嗯，打印出来“喜怒哀乐愁”，没毛病。可是 stu2 是个乐天派，他咋也跟着一起愁了呢？！肯定不对嘛～',
    '这就是单纯的原型链继承的缺点，如果一个实例不小心修改了原型对象上引用类型的值，会导致其它实例也跟着受影响。',
    '<b>因此，我们得出结论，原型上任何基础类型的属性值都不会通过实例被重写，但是引用类型的属性值会受到实例的影响而修改。</b>',
    '<b>1.2 原型链不能实现子类向父类中传参。这里就不细说了。</b>',
    'https://www.cnblogs.com/sarahwang/p/6870072.html'
  ]
}
export default prototype1
